{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/tingyuan.lu/chatkit/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _possibleConstructorReturn = require(\"/Users/tingyuan.lu/chatkit/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/tingyuan.lu/chatkit/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/tingyuan.lu/chatkit/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _wrapNativeSuper = require(\"/Users/tingyuan.lu/chatkit/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nvar net = require('net');\n\nvar TimeoutError =\n/*#__PURE__*/\nfunction (_Error) {\n  _inherits(TimeoutError, _Error);\n\n  function TimeoutError(threshold, event) {\n    var _this;\n\n    _classCallCheck(this, TimeoutError);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TimeoutError).call(this, \"Timeout awaiting '\".concat(event, \"' for \").concat(threshold, \"ms\")));\n    _this.name = 'TimeoutError';\n    _this.code = 'ETIMEDOUT';\n    _this.event = event;\n    return _this;\n  }\n\n  return TimeoutError;\n}(_wrapNativeSuper(Error));\n\nvar reentry = Symbol('reentry');\n\nvar noop = function noop() {};\n\nmodule.exports = function (request, delays, options) {\n  /* istanbul ignore next: this makes sure timed-out isn't called twice */\n  if (request[reentry]) {\n    return;\n  }\n\n  request[reentry] = true;\n  var stopNewTimeouts = false;\n\n  var addTimeout = function addTimeout(delay, callback) {\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    // An error had been thrown before. Going further would result in uncaught errors.\n    // See https://github.com/sindresorhus/got/issues/631#issuecomment-435675051\n    if (stopNewTimeouts) {\n      return noop;\n    } // Event loop order is timers, poll, immediates.\n    // The timed event may emit during the current tick poll phase, so\n    // defer calling the handler until the poll phase completes.\n\n\n    var immediate;\n    var timeout = setTimeout(function () {\n      immediate = setImmediate.apply(void 0, [callback, delay].concat(args));\n      /* istanbul ignore next: added in node v9.7.0 */\n\n      if (immediate.unref) {\n        immediate.unref();\n      }\n    }, delay);\n    /* istanbul ignore next: in order to support electron renderer */\n\n    if (timeout.unref) {\n      timeout.unref();\n    }\n\n    var cancel = function cancel() {\n      clearTimeout(timeout);\n      clearImmediate(immediate);\n    };\n\n    cancelers.push(cancel);\n    return cancel;\n  };\n\n  var host = options.host,\n      hostname = options.hostname;\n\n  var timeoutHandler = function timeoutHandler(delay, event) {\n    request.emit('error', new TimeoutError(delay, event));\n    request.once('error', function () {}); // Ignore the `socket hung up` error made by request.abort()\n\n    request.abort();\n  };\n\n  var cancelers = [];\n\n  var cancelTimeouts = function cancelTimeouts() {\n    stopNewTimeouts = true;\n    cancelers.forEach(function (cancelTimeout) {\n      return cancelTimeout();\n    });\n  };\n\n  request.once('error', cancelTimeouts);\n  request.once('response', function (response) {\n    response.once('end', cancelTimeouts);\n  });\n\n  if (delays.request !== undefined) {\n    addTimeout(delays.request, timeoutHandler, 'request');\n  }\n\n  if (delays.socket !== undefined) {\n    var socketTimeoutHandler = function socketTimeoutHandler() {\n      timeoutHandler(delays.socket, 'socket');\n    };\n\n    request.setTimeout(delays.socket, socketTimeoutHandler); // `request.setTimeout(0)` causes a memory leak.\n    // We can just remove the listener and forget about the timer - it's unreffed.\n    // See https://github.com/sindresorhus/got/issues/690\n\n    cancelers.push(function () {\n      return request.removeListener('timeout', socketTimeoutHandler);\n    });\n  }\n\n  if (delays.lookup !== undefined && !request.socketPath && !net.isIP(hostname || host)) {\n    request.once('socket', function (socket) {\n      /* istanbul ignore next: hard to test */\n      if (socket.connecting) {\n        var cancelTimeout = addTimeout(delays.lookup, timeoutHandler, 'lookup');\n        socket.once('lookup', cancelTimeout);\n      }\n    });\n  }\n\n  if (delays.connect !== undefined) {\n    request.once('socket', function (socket) {\n      /* istanbul ignore next: hard to test */\n      if (socket.connecting) {\n        var timeConnect = function timeConnect() {\n          return addTimeout(delays.connect, timeoutHandler, 'connect');\n        };\n\n        if (request.socketPath || net.isIP(hostname || host)) {\n          socket.once('connect', timeConnect());\n        } else {\n          socket.once('lookup', function (error) {\n            if (error === null) {\n              socket.once('connect', timeConnect());\n            }\n          });\n        }\n      }\n    });\n  }\n\n  if (delays.secureConnect !== undefined && options.protocol === 'https:') {\n    request.once('socket', function (socket) {\n      /* istanbul ignore next: hard to test */\n      if (socket.connecting) {\n        socket.once('connect', function () {\n          var cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, 'secureConnect');\n          socket.once('secureConnect', cancelTimeout);\n        });\n      }\n    });\n  }\n\n  if (delays.send !== undefined) {\n    request.once('socket', function (socket) {\n      var timeRequest = function timeRequest() {\n        return addTimeout(delays.send, timeoutHandler, 'send');\n      };\n      /* istanbul ignore next: hard to test */\n\n\n      if (socket.connecting) {\n        socket.once('connect', function () {\n          request.once('upload-complete', timeRequest());\n        });\n      } else {\n        request.once('upload-complete', timeRequest());\n      }\n    });\n  }\n\n  if (delays.response !== undefined) {\n    request.once('upload-complete', function () {\n      var cancelTimeout = addTimeout(delays.response, timeoutHandler, 'response');\n      request.once('response', cancelTimeout);\n    });\n  }\n};\n\nmodule.exports.TimeoutError = TimeoutError;","map":null,"metadata":{},"sourceType":"script"}