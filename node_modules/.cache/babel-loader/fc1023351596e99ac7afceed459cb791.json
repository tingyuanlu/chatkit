{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/tingyuan.lu/chatkit/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _require = require('stream'),\n    PassThrough = _require.PassThrough;\n\nvar duplexer3 = require('duplexer3');\n\nvar requestAsEventEmitter = require('./request-as-event-emitter');\n\nvar _require2 = require('./errors'),\n    HTTPError = _require2.HTTPError,\n    ReadError = _require2.ReadError;\n\nmodule.exports = function (options) {\n  var input = new PassThrough();\n  var output = new PassThrough();\n  var proxy = duplexer3(input, output);\n  var piped = new Set();\n  var isFinished = false;\n\n  options.retry.retries = function () {\n    return 0;\n  };\n\n  if (options.body) {\n    proxy.write = function () {\n      throw new Error('Got\\'s stream is not writable when the `body` option is used');\n    };\n  }\n\n  var emitter = requestAsEventEmitter(options, input); // Cancels the request\n\n  proxy._destroy = emitter.abort;\n  emitter.on('response', function (response) {\n    var statusCode = response.statusCode;\n    response.on('error', function (error) {\n      proxy.emit('error', new ReadError(error, options));\n    });\n\n    if (options.throwHttpErrors && statusCode !== 304 && (statusCode < 200 || statusCode > 299)) {\n      proxy.emit('error', new HTTPError(response, options), null, response);\n      return;\n    }\n\n    isFinished = true;\n    response.pipe(output);\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = piped[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var destination = _step.value;\n\n        if (destination.headersSent) {\n          continue;\n        }\n\n        for (var _i = 0, _Object$entries = Object.entries(response.headers); _i < _Object$entries.length; _i++) {\n          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n              key = _Object$entries$_i[0],\n              value = _Object$entries$_i[1];\n\n          // Got gives *decompressed* data. Overriding `content-encoding` header would result in an error.\n          // It's not possible to decompress already decompressed data, is it?\n          var allowed = options.decompress ? key !== 'content-encoding' : true;\n\n          if (allowed) {\n            destination.setHeader(key, value);\n          }\n        }\n\n        destination.statusCode = response.statusCode;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    proxy.emit('response', response);\n  });\n  ['error', 'request', 'redirect', 'uploadProgress', 'downloadProgress'].forEach(function (event) {\n    return emitter.on(event, function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return proxy.emit.apply(proxy, [event].concat(args));\n    });\n  });\n  var pipe = proxy.pipe.bind(proxy);\n  var unpipe = proxy.unpipe.bind(proxy);\n\n  proxy.pipe = function (destination, options) {\n    if (isFinished) {\n      throw new Error('Failed to pipe. The response has been emitted already.');\n    }\n\n    var result = pipe(destination, options);\n\n    if (Reflect.has(destination, 'setHeader')) {\n      piped.add(destination);\n    }\n\n    return result;\n  };\n\n  proxy.unpipe = function (stream) {\n    piped.delete(stream);\n    return unpipe(stream);\n  };\n\n  return proxy;\n};","map":null,"metadata":{},"sourceType":"script"}