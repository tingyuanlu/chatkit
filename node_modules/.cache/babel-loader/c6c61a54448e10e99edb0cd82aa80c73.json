{"ast":null,"code":"'use strict';\n\nvar _require = require('stream'),\n    Transform = _require.Transform;\n\nmodule.exports = {\n  download: function download(response, emitter, downloadBodySize) {\n    var downloaded = 0;\n    return new Transform({\n      transform: function transform(chunk, encoding, callback) {\n        downloaded += chunk.length;\n        var percent = downloadBodySize ? downloaded / downloadBodySize : 0; // Let `flush()` be responsible for emitting the last event\n\n        if (percent < 1) {\n          emitter.emit('downloadProgress', {\n            percent: percent,\n            transferred: downloaded,\n            total: downloadBodySize\n          });\n        }\n\n        callback(null, chunk);\n      },\n      flush: function flush(callback) {\n        emitter.emit('downloadProgress', {\n          percent: 1,\n          transferred: downloaded,\n          total: downloadBodySize\n        });\n        callback();\n      }\n    });\n  },\n  upload: function upload(request, emitter, uploadBodySize) {\n    var uploadEventFrequency = 150;\n    var uploaded = 0;\n    var progressInterval;\n    emitter.emit('uploadProgress', {\n      percent: 0,\n      transferred: 0,\n      total: uploadBodySize\n    });\n    request.once('error', function () {\n      clearInterval(progressInterval);\n    });\n    request.once('response', function () {\n      clearInterval(progressInterval);\n      emitter.emit('uploadProgress', {\n        percent: 1,\n        transferred: uploaded,\n        total: uploadBodySize\n      });\n    });\n    request.once('socket', function (socket) {\n      var onSocketConnect = function onSocketConnect() {\n        progressInterval = setInterval(function () {\n          var lastUploaded = uploaded;\n          /* istanbul ignore next: see #490 (occurs randomly!) */\n\n          var headersSize = request._header ? Buffer.byteLength(request._header) : 0;\n          uploaded = socket.bytesWritten - headersSize; // Don't emit events with unchanged progress and\n          // prevent last event from being emitted, because\n          // it's emitted when `response` is emitted\n\n          if (uploaded === lastUploaded || uploaded === uploadBodySize) {\n            return;\n          }\n\n          emitter.emit('uploadProgress', {\n            percent: uploadBodySize ? uploaded / uploadBodySize : 0,\n            transferred: uploaded,\n            total: uploadBodySize\n          });\n        }, uploadEventFrequency);\n      };\n      /* istanbul ignore next: hard to test */\n\n\n      if (socket.connecting) {\n        socket.once('connect', onSocketConnect);\n      } else if (socket.writable) {\n        // The socket is being reused from pool,\n        // so the connect event will not be emitted\n        onSocketConnect();\n      }\n    });\n  }\n};","map":null,"metadata":{},"sourceType":"script"}