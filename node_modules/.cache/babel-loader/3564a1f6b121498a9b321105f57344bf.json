{"ast":null,"code":"'use strict';\n\nvar _possibleConstructorReturn = require(\"/Users/tingyuan.lu/chatkit/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/tingyuan.lu/chatkit/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/tingyuan.lu/chatkit/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/Users/tingyuan.lu/chatkit/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _wrapNativeSuper = require(\"/Users/tingyuan.lu/chatkit/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nvar _regeneratorRuntime = require(\"/Users/tingyuan.lu/chatkit/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/tingyuan.lu/chatkit/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _objectSpread = require(\"/Users/tingyuan.lu/chatkit/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar _toArray = require(\"/Users/tingyuan.lu/chatkit/node_modules/@babel/runtime/helpers/toArray\");\n\nvar _classCallCheck = require(\"/Users/tingyuan.lu/chatkit/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/tingyuan.lu/chatkit/node_modules/@babel/runtime/helpers/createClass\");\n\nvar EventEmitter = require('events');\n\nvar urlLib = require('url');\n\nvar normalizeUrl = require('normalize-url');\n\nvar getStream = require('get-stream');\n\nvar CachePolicy = require('http-cache-semantics');\n\nvar Response = require('responselike');\n\nvar lowercaseKeys = require('lowercase-keys');\n\nvar cloneResponse = require('clone-response');\n\nvar Keyv = require('keyv');\n\nvar CacheableRequest =\n/*#__PURE__*/\nfunction () {\n  function CacheableRequest(request, cacheAdapter) {\n    _classCallCheck(this, CacheableRequest);\n\n    if (typeof request !== 'function') {\n      throw new TypeError('Parameter `request` must be a function');\n    }\n\n    this.cache = new Keyv({\n      uri: typeof cacheAdapter === 'string' && cacheAdapter,\n      store: typeof cacheAdapter !== 'string' && cacheAdapter,\n      namespace: 'cacheable-request'\n    });\n    return this.createCacheableRequest(request);\n  }\n\n  _createClass(CacheableRequest, [{\n    key: \"createCacheableRequest\",\n    value: function createCacheableRequest(request) {\n      var _this = this;\n\n      return function (opts, cb) {\n        var url;\n\n        if (typeof opts === 'string') {\n          url = normalizeUrlObject(urlLib.parse(opts));\n          opts = {};\n        } else if (opts instanceof urlLib.URL) {\n          url = normalizeUrlObject(urlLib.parse(opts.toString()));\n          opts = {};\n        } else {\n          var _split = (opts.path || '').split('?'),\n              _split2 = _toArray(_split),\n              pathname = _split2[0],\n              searchParts = _split2.slice(1);\n\n          var search = searchParts.length > 0 ? \"?\".concat(searchParts.join('?')) : '';\n          url = normalizeUrlObject(_objectSpread({}, opts, {\n            pathname: pathname,\n            search: search\n          }));\n        }\n\n        opts = _objectSpread({\n          headers: {},\n          method: 'GET',\n          cache: true,\n          strictTtl: false,\n          automaticFailover: false\n        }, opts, urlObjectToRequestOptions(url));\n        opts.headers = lowercaseKeys(opts.headers);\n        var ee = new EventEmitter();\n        var normalizedUrlString = normalizeUrl(urlLib.format(url), {\n          stripWWW: false,\n          removeTrailingSlash: false\n        });\n        var key = \"\".concat(opts.method, \":\").concat(normalizedUrlString);\n        var revalidate = false;\n        var madeRequest = false;\n\n        var makeRequest = function makeRequest(opts) {\n          madeRequest = true;\n          var requestErrored = false;\n          var requestErrorCallback;\n          var requestErrorPromise = new Promise(function (resolve) {\n            requestErrorCallback = function requestErrorCallback() {\n              requestErrored = true;\n              resolve();\n            };\n          });\n\n          var handler = function handler(response) {\n            if (revalidate && !opts.forceRefresh) {\n              response.status = response.statusCode;\n              var revalidatedPolicy = CachePolicy.fromObject(revalidate.cachePolicy).revalidatedPolicy(opts, response);\n\n              if (!revalidatedPolicy.modified) {\n                var headers = revalidatedPolicy.policy.responseHeaders();\n                response = new Response(revalidate.statusCode, headers, revalidate.body, revalidate.url);\n                response.cachePolicy = revalidatedPolicy.policy;\n                response.fromCache = true;\n              }\n            }\n\n            if (!response.fromCache) {\n              response.cachePolicy = new CachePolicy(opts, response, opts);\n              response.fromCache = false;\n            }\n\n            var clonedResponse;\n\n            if (opts.cache && response.cachePolicy.storable()) {\n              clonedResponse = cloneResponse(response);\n\n              _asyncToGenerator(\n              /*#__PURE__*/\n              _regeneratorRuntime.mark(function _callee() {\n                var bodyPromise, body, value, ttl;\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        _context.prev = 0;\n                        bodyPromise = getStream.buffer(response);\n                        _context.next = 4;\n                        return Promise.race([requestErrorPromise, new Promise(function (resolve) {\n                          return response.once('end', resolve);\n                        })]);\n\n                      case 4:\n                        if (!requestErrored) {\n                          _context.next = 6;\n                          break;\n                        }\n\n                        return _context.abrupt(\"return\");\n\n                      case 6:\n                        _context.next = 8;\n                        return bodyPromise;\n\n                      case 8:\n                        body = _context.sent;\n                        value = {\n                          cachePolicy: response.cachePolicy.toObject(),\n                          url: response.url,\n                          statusCode: response.fromCache ? revalidate.statusCode : response.statusCode,\n                          body: body\n                        };\n                        ttl = opts.strictTtl ? response.cachePolicy.timeToLive() : undefined;\n\n                        if (opts.maxTtl) {\n                          ttl = ttl ? Math.min(ttl, opts.maxTtl) : opts.maxTtl;\n                        }\n\n                        _context.next = 14;\n                        return _this.cache.set(key, value, ttl);\n\n                      case 14:\n                        _context.next = 19;\n                        break;\n\n                      case 16:\n                        _context.prev = 16;\n                        _context.t0 = _context[\"catch\"](0);\n                        ee.emit('error', new CacheableRequest.CacheError(_context.t0));\n\n                      case 19:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee, null, [[0, 16]]);\n              }))();\n            } else if (opts.cache && revalidate) {\n              _asyncToGenerator(\n              /*#__PURE__*/\n              _regeneratorRuntime.mark(function _callee2() {\n                return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                  while (1) {\n                    switch (_context2.prev = _context2.next) {\n                      case 0:\n                        _context2.prev = 0;\n                        _context2.next = 3;\n                        return _this.cache.delete(key);\n\n                      case 3:\n                        _context2.next = 8;\n                        break;\n\n                      case 5:\n                        _context2.prev = 5;\n                        _context2.t0 = _context2[\"catch\"](0);\n                        ee.emit('error', new CacheableRequest.CacheError(_context2.t0));\n\n                      case 8:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }\n                }, _callee2, null, [[0, 5]]);\n              }))();\n            }\n\n            ee.emit('response', clonedResponse || response);\n\n            if (typeof cb === 'function') {\n              cb(clonedResponse || response);\n            }\n          };\n\n          try {\n            var req = request(opts, handler);\n            req.once('error', requestErrorCallback);\n            req.once('abort', requestErrorCallback);\n            ee.emit('request', req);\n          } catch (err) {\n            ee.emit('error', new CacheableRequest.RequestError(err));\n          }\n        };\n\n        _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee4() {\n          var get;\n          return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  get =\n                  /*#__PURE__*/\n                  function () {\n                    var _ref4 = _asyncToGenerator(\n                    /*#__PURE__*/\n                    _regeneratorRuntime.mark(function _callee3(opts) {\n                      var cacheEntry, policy, headers, response;\n                      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                        while (1) {\n                          switch (_context3.prev = _context3.next) {\n                            case 0:\n                              _context3.next = 2;\n                              return Promise.resolve();\n\n                            case 2:\n                              if (!opts.cache) {\n                                _context3.next = 8;\n                                break;\n                              }\n\n                              _context3.next = 5;\n                              return _this.cache.get(key);\n\n                            case 5:\n                              _context3.t0 = _context3.sent;\n                              _context3.next = 9;\n                              break;\n\n                            case 8:\n                              _context3.t0 = undefined;\n\n                            case 9:\n                              cacheEntry = _context3.t0;\n\n                              if (!(typeof cacheEntry === 'undefined')) {\n                                _context3.next = 12;\n                                break;\n                              }\n\n                              return _context3.abrupt(\"return\", makeRequest(opts));\n\n                            case 12:\n                              policy = CachePolicy.fromObject(cacheEntry.cachePolicy);\n\n                              if (policy.satisfiesWithoutRevalidation(opts) && !opts.forceRefresh) {\n                                headers = policy.responseHeaders();\n                                response = new Response(cacheEntry.statusCode, headers, cacheEntry.body, cacheEntry.url);\n                                response.cachePolicy = policy;\n                                response.fromCache = true;\n                                ee.emit('response', response);\n\n                                if (typeof cb === 'function') {\n                                  cb(response);\n                                }\n                              } else {\n                                revalidate = cacheEntry;\n                                opts.headers = policy.revalidationHeaders(opts);\n                                makeRequest(opts);\n                              }\n\n                            case 14:\n                            case \"end\":\n                              return _context3.stop();\n                          }\n                        }\n                      }, _callee3);\n                    }));\n\n                    return function get(_x) {\n                      return _ref4.apply(this, arguments);\n                    };\n                  }();\n\n                  _this.cache.on('error', function (err) {\n                    return ee.emit('error', new CacheableRequest.CacheError(err));\n                  });\n\n                  _context4.prev = 2;\n                  _context4.next = 5;\n                  return get(opts);\n\n                case 5:\n                  _context4.next = 11;\n                  break;\n\n                case 7:\n                  _context4.prev = 7;\n                  _context4.t0 = _context4[\"catch\"](2);\n\n                  if (opts.automaticFailover && !madeRequest) {\n                    makeRequest(opts);\n                  }\n\n                  ee.emit('error', new CacheableRequest.CacheError(_context4.t0));\n\n                case 11:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4, null, [[2, 7]]);\n        }))();\n\n        return ee;\n      };\n    }\n  }]);\n\n  return CacheableRequest;\n}();\n\nfunction urlObjectToRequestOptions(url) {\n  var options = _objectSpread({}, url);\n\n  options.path = \"\".concat(url.pathname || '/').concat(url.search || '');\n  delete options.pathname;\n  delete options.search;\n  return options;\n}\n\nfunction normalizeUrlObject(url) {\n  // If url was parsed by url.parse or new URL:\n  // - hostname will be set\n  // - host will be hostname[:port]\n  // - port will be set if it was explicit in the parsed string\n  // Otherwise, url was from request options:\n  // - hostname or host may be set\n  // - host shall not have port encoded\n  return {\n    protocol: url.protocol,\n    auth: url.auth,\n    hostname: url.hostname || url.host || 'localhost',\n    port: url.port,\n    pathname: url.pathname,\n    search: url.search\n  };\n}\n\nCacheableRequest.RequestError =\n/*#__PURE__*/\nfunction (_Error) {\n  _inherits(_class, _Error);\n\n  function _class(err) {\n    var _this2;\n\n    _classCallCheck(this, _class);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(_class).call(this, err.message));\n    _this2.name = 'RequestError';\n    Object.assign(_assertThisInitialized(_assertThisInitialized(_this2)), err);\n    return _this2;\n  }\n\n  return _class;\n}(_wrapNativeSuper(Error));\n\nCacheableRequest.CacheError =\n/*#__PURE__*/\nfunction (_Error2) {\n  _inherits(_class2, _Error2);\n\n  function _class2(err) {\n    var _this3;\n\n    _classCallCheck(this, _class2);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(_class2).call(this, err.message));\n    _this3.name = 'CacheError';\n    Object.assign(_assertThisInitialized(_assertThisInitialized(_this3)), err);\n    return _this3;\n  }\n\n  return _class2;\n}(_wrapNativeSuper(Error));\n\nmodule.exports = CacheableRequest;","map":null,"metadata":{},"sourceType":"script"}