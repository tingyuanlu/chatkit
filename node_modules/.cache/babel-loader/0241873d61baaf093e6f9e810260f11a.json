{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/tingyuan.lu/chatkit/node_modules/@babel/runtime/regenerator\");\n\nvar _objectSpread = require(\"/Users/tingyuan.lu/chatkit/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar _slicedToArray = require(\"/Users/tingyuan.lu/chatkit/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _asyncToGenerator = require(\"/Users/tingyuan.lu/chatkit/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar EventEmitter = require('events');\n\nvar getStream = require('get-stream');\n\nvar is = require('@sindresorhus/is');\n\nvar PCancelable = require('p-cancelable');\n\nvar requestAsEventEmitter = require('./request-as-event-emitter');\n\nvar _require = require('./errors'),\n    HTTPError = _require.HTTPError,\n    ParseError = _require.ParseError,\n    ReadError = _require.ReadError;\n\nvar _require2 = require('./merge'),\n    mergeOptions = _require2.options;\n\nvar _require3 = require('./normalize-arguments'),\n    reNormalize = _require3.reNormalize;\n\nvar asPromise = function asPromise(options) {\n  var proxy = new EventEmitter();\n  var promise = new PCancelable(function (resolve, reject, onCancel) {\n    var emitter = requestAsEventEmitter(options);\n    onCancel(emitter.abort);\n    emitter.on('response',\n    /*#__PURE__*/\n    function () {\n      var _ref = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(response) {\n        var stream, data, limitStatusCode, _loop, _i, _Object$entries, _response, statusCode, parseError, error;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                proxy.emit('response', response);\n                stream = is.null(options.encoding) ? getStream.buffer(response) : getStream(response, options);\n                _context2.prev = 2;\n                _context2.next = 5;\n                return stream;\n\n              case 5:\n                data = _context2.sent;\n                _context2.next = 12;\n                break;\n\n              case 8:\n                _context2.prev = 8;\n                _context2.t0 = _context2[\"catch\"](2);\n                reject(new ReadError(_context2.t0, options));\n                return _context2.abrupt(\"return\");\n\n              case 12:\n                limitStatusCode = options.followRedirect ? 299 : 399;\n                response.body = data;\n                _context2.prev = 14;\n                _loop =\n                /*#__PURE__*/\n                _regeneratorRuntime.mark(function _loop() {\n                  var _Object$entries$_i, index, hook;\n\n                  return _regeneratorRuntime.wrap(function _loop$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), index = _Object$entries$_i[0], hook = _Object$entries$_i[1];\n                          _context.next = 3;\n                          return hook(response, function (updatedOptions) {\n                            updatedOptions = reNormalize(mergeOptions(options, _objectSpread({}, updatedOptions, {\n                              retry: 0,\n                              throwHttpErrors: false\n                            }))); // Remove any further hooks for that request, because we we'll call them anyway.\n                            // The loop continues. We don't want duplicates (asPromise recursion).\n\n                            updatedOptions.hooks.afterResponse = options.hooks.afterResponse.slice(0, index);\n                            return asPromise(updatedOptions);\n                          });\n\n                        case 3:\n                          response = _context.sent;\n\n                        case 4:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _loop);\n                });\n                _i = 0, _Object$entries = Object.entries(options.hooks.afterResponse);\n\n              case 17:\n                if (!(_i < _Object$entries.length)) {\n                  _context2.next = 22;\n                  break;\n                }\n\n                return _context2.delegateYield(_loop(), \"t1\", 19);\n\n              case 19:\n                _i++;\n                _context2.next = 17;\n                break;\n\n              case 22:\n                _context2.next = 28;\n                break;\n\n              case 24:\n                _context2.prev = 24;\n                _context2.t2 = _context2[\"catch\"](14);\n                reject(_context2.t2);\n                return _context2.abrupt(\"return\");\n\n              case 28:\n                _response = response, statusCode = _response.statusCode;\n\n                if (!(options.json && response.body)) {\n                  _context2.next = 41;\n                  break;\n                }\n\n                _context2.prev = 30;\n                response.body = JSON.parse(response.body);\n                _context2.next = 41;\n                break;\n\n              case 34:\n                _context2.prev = 34;\n                _context2.t3 = _context2[\"catch\"](30);\n\n                if (!(statusCode >= 200 && statusCode < 300)) {\n                  _context2.next = 41;\n                  break;\n                }\n\n                parseError = new ParseError(_context2.t3, statusCode, options, data);\n                Object.defineProperty(parseError, 'response', {\n                  value: response\n                });\n                reject(parseError);\n                return _context2.abrupt(\"return\");\n\n              case 41:\n                if (!(statusCode !== 304 && (statusCode < 200 || statusCode > limitStatusCode))) {\n                  _context2.next = 50;\n                  break;\n                }\n\n                error = new HTTPError(response, options);\n                Object.defineProperty(error, 'response', {\n                  value: response\n                });\n\n                if (!(emitter.retry(error) === false)) {\n                  _context2.next = 49;\n                  break;\n                }\n\n                if (!options.throwHttpErrors) {\n                  _context2.next = 48;\n                  break;\n                }\n\n                reject(error);\n                return _context2.abrupt(\"return\");\n\n              case 48:\n                resolve(response);\n\n              case 49:\n                return _context2.abrupt(\"return\");\n\n              case 50:\n                resolve(response);\n\n              case 51:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee, null, [[2, 8], [14, 24], [30, 34]]);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n    emitter.once('error', reject);\n    ['request', 'redirect', 'uploadProgress', 'downloadProgress'].forEach(function (event) {\n      return emitter.on(event, function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        return proxy.emit.apply(proxy, [event].concat(args));\n      });\n    });\n  });\n\n  promise.on = function (name, fn) {\n    proxy.on(name, fn);\n    return promise;\n  };\n\n  return promise;\n};\n\nmodule.exports = asPromise;","map":null,"metadata":{},"sourceType":"script"}