{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"/Users/tingyuan.lu/chatkit/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar _regeneratorRuntime = require(\"/Users/tingyuan.lu/chatkit/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/tingyuan.lu/chatkit/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _require = require('url'),\n    URL = _require.URL; // TODO: Use the `URL` global when targeting Node.js 10\n\n\nvar util = require('util');\n\nvar EventEmitter = require('events');\n\nvar http = require('http');\n\nvar https = require('https');\n\nvar urlLib = require('url');\n\nvar CacheableRequest = require('cacheable-request');\n\nvar toReadableStream = require('to-readable-stream');\n\nvar is = require('@sindresorhus/is');\n\nvar timer = require('@szmarczak/http-timer');\n\nvar timedOut = require('./utils/timed-out');\n\nvar getBodySize = require('./utils/get-body-size');\n\nvar getResponse = require('./get-response');\n\nvar progress = require('./progress');\n\nvar _require2 = require('./errors'),\n    CacheError = _require2.CacheError,\n    UnsupportedProtocolError = _require2.UnsupportedProtocolError,\n    MaxRedirectsError = _require2.MaxRedirectsError,\n    RequestError = _require2.RequestError,\n    TimeoutError = _require2.TimeoutError;\n\nvar urlToOptions = require('./utils/url-to-options');\n\nvar getMethodRedirectCodes = new Set([300, 301, 302, 303, 304, 305, 307, 308]);\nvar allMethodRedirectCodes = new Set([300, 303, 307, 308]);\n\nmodule.exports = function (options, input) {\n  var emitter = new EventEmitter();\n  var redirects = [];\n  var currentRequest;\n  var requestUrl;\n  var redirectString;\n  var uploadBodySize;\n  var retryCount = 0;\n  var shouldAbort = false;\n  var setCookie = options.cookieJar ? util.promisify(options.cookieJar.setCookie.bind(options.cookieJar)) : null;\n  var getCookieString = options.cookieJar ? util.promisify(options.cookieJar.getCookieString.bind(options.cookieJar)) : null;\n  var agents = is.object(options.agent) ? options.agent : null;\n\n  var emitError =\n  /*#__PURE__*/\n  function () {\n    var _ref = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee(error) {\n      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, hook;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _iteratorError = undefined;\n              _context.prev = 4;\n              _iterator = options.hooks.beforeError[Symbol.iterator]();\n\n            case 6:\n              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                _context.next = 14;\n                break;\n              }\n\n              hook = _step.value;\n              _context.next = 10;\n              return hook(error);\n\n            case 10:\n              error = _context.sent;\n\n            case 11:\n              _iteratorNormalCompletion = true;\n              _context.next = 6;\n              break;\n\n            case 14:\n              _context.next = 20;\n              break;\n\n            case 16:\n              _context.prev = 16;\n              _context.t0 = _context[\"catch\"](4);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 20:\n              _context.prev = 20;\n              _context.prev = 21;\n\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n\n            case 23:\n              _context.prev = 23;\n\n              if (!_didIteratorError) {\n                _context.next = 26;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 26:\n              return _context.finish(23);\n\n            case 27:\n              return _context.finish(20);\n\n            case 28:\n              emitter.emit('error', error);\n              _context.next = 34;\n              break;\n\n            case 31:\n              _context.prev = 31;\n              _context.t1 = _context[\"catch\"](0);\n              emitter.emit('error', _context.t1);\n\n            case 34:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[0, 31], [4, 16, 20, 28], [21,, 23, 27]]);\n    }));\n\n    return function emitError(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  var get =\n  /*#__PURE__*/\n  function () {\n    var _ref2 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee3(options) {\n      var currentUrl, fn, protocolName, r, electron, cookieString, timings, handleResponse, handleRequest, cacheableRequest, cacheRequest;\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              currentUrl = redirectString || requestUrl;\n\n              if (!(options.protocol !== 'http:' && options.protocol !== 'https:')) {\n                _context3.next = 3;\n                break;\n              }\n\n              throw new UnsupportedProtocolError(options);\n\n            case 3:\n              decodeURI(currentUrl);\n\n              if (is.function(options.request)) {\n                fn = {\n                  request: options.request\n                };\n              } else {\n                fn = options.protocol === 'https:' ? https : http;\n              }\n\n              if (agents) {\n                protocolName = options.protocol === 'https:' ? 'https' : 'http';\n                options.agent = agents[protocolName] || options.agent;\n              }\n              /* istanbul ignore next: electron.net is broken */\n\n\n              if (options.useElectronNet && process.versions.electron) {\n                r = {\n                  x: require\n                }['yx'.slice(1)]; // Trick webpack\n\n                electron = r('electron');\n                fn = electron.net || electron.remote.net;\n              }\n\n              if (!options.cookieJar) {\n                _context3.next = 12;\n                break;\n              }\n\n              _context3.next = 10;\n              return getCookieString(currentUrl, {});\n\n            case 10:\n              cookieString = _context3.sent;\n\n              if (is.nonEmptyString(cookieString)) {\n                options.headers.cookie = cookieString;\n              }\n\n            case 12:\n              handleResponse =\n              /*#__PURE__*/\n              function () {\n                var _ref3 = _asyncToGenerator(\n                /*#__PURE__*/\n                _regeneratorRuntime.mark(function _callee2(response) {\n                  var _response, statusCode, rawCookies, redirectBuffer, redirectURL, redirectOptions, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, hook;\n\n                  return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                    while (1) {\n                      switch (_context2.prev = _context2.next) {\n                        case 0:\n                          _context2.prev = 0;\n\n                          /* istanbul ignore next: fixes https://github.com/electron/electron/blob/cbb460d47628a7a146adf4419ed48550a98b2923/lib/browser/api/net.js#L59-L65 */\n                          if (options.useElectronNet) {\n                            response = new Proxy(response, {\n                              get: function get(target, name) {\n                                if (name === 'trailers' || name === 'rawTrailers') {\n                                  return [];\n                                }\n\n                                var value = target[name];\n                                return is.function(value) ? value.bind(target) : value;\n                              }\n                            });\n                          }\n\n                          _response = response, statusCode = _response.statusCode;\n                          response.url = currentUrl;\n                          response.requestUrl = requestUrl;\n                          response.retryCount = retryCount;\n                          response.timings = timings;\n                          response.redirectUrls = redirects;\n                          response.request = {\n                            gotOptions: options\n                          };\n                          rawCookies = response.headers['set-cookie'];\n\n                          if (!(options.cookieJar && rawCookies)) {\n                            _context2.next = 13;\n                            break;\n                          }\n\n                          _context2.next = 13;\n                          return Promise.all(rawCookies.map(function (rawCookie) {\n                            return setCookie(rawCookie, response.url);\n                          }));\n\n                        case 13:\n                          if (!(options.followRedirect && 'location' in response.headers)) {\n                            _context2.next = 54;\n                            break;\n                          }\n\n                          if (!(allMethodRedirectCodes.has(statusCode) || getMethodRedirectCodes.has(statusCode) && (options.method === 'GET' || options.method === 'HEAD'))) {\n                            _context2.next = 54;\n                            break;\n                          }\n\n                          response.resume(); // We're being redirected, we don't care about the response.\n\n                          if (statusCode === 303) {\n                            // Server responded with \"see other\", indicating that the resource exists at another location,\n                            // and the client should request it from that location via GET or HEAD.\n                            options.method = 'GET';\n                          }\n\n                          if (!(redirects.length >= 10)) {\n                            _context2.next = 19;\n                            break;\n                          }\n\n                          throw new MaxRedirectsError(statusCode, redirects, options);\n\n                        case 19:\n                          // Handles invalid URLs. See https://github.com/sindresorhus/got/issues/604\n                          redirectBuffer = Buffer.from(response.headers.location, 'binary').toString();\n                          redirectURL = new URL(redirectBuffer, currentUrl);\n                          redirectString = redirectURL.toString();\n                          redirects.push(redirectString);\n                          redirectOptions = _objectSpread({}, options, urlToOptions(redirectURL));\n                          _iteratorNormalCompletion2 = true;\n                          _didIteratorError2 = false;\n                          _iteratorError2 = undefined;\n                          _context2.prev = 27;\n                          _iterator2 = options.hooks.beforeRedirect[Symbol.iterator]();\n\n                        case 29:\n                          if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {\n                            _context2.next = 36;\n                            break;\n                          }\n\n                          hook = _step2.value;\n                          _context2.next = 33;\n                          return hook(redirectOptions);\n\n                        case 33:\n                          _iteratorNormalCompletion2 = true;\n                          _context2.next = 29;\n                          break;\n\n                        case 36:\n                          _context2.next = 42;\n                          break;\n\n                        case 38:\n                          _context2.prev = 38;\n                          _context2.t0 = _context2[\"catch\"](27);\n                          _didIteratorError2 = true;\n                          _iteratorError2 = _context2.t0;\n\n                        case 42:\n                          _context2.prev = 42;\n                          _context2.prev = 43;\n\n                          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                            _iterator2.return();\n                          }\n\n                        case 45:\n                          _context2.prev = 45;\n\n                          if (!_didIteratorError2) {\n                            _context2.next = 48;\n                            break;\n                          }\n\n                          throw _iteratorError2;\n\n                        case 48:\n                          return _context2.finish(45);\n\n                        case 49:\n                          return _context2.finish(42);\n\n                        case 50:\n                          emitter.emit('redirect', response, redirectOptions);\n                          _context2.next = 53;\n                          return get(redirectOptions);\n\n                        case 53:\n                          return _context2.abrupt(\"return\");\n\n                        case 54:\n                          getResponse(response, options, emitter);\n                          _context2.next = 60;\n                          break;\n\n                        case 57:\n                          _context2.prev = 57;\n                          _context2.t1 = _context2[\"catch\"](0);\n                          emitError(_context2.t1);\n\n                        case 60:\n                        case \"end\":\n                          return _context2.stop();\n                      }\n                    }\n                  }, _callee2, null, [[0, 57], [27, 38, 42, 50], [43,, 45, 49]]);\n                }));\n\n                return function handleResponse(_x3) {\n                  return _ref3.apply(this, arguments);\n                };\n              }();\n\n              handleRequest = function handleRequest(request) {\n                if (shouldAbort) {\n                  request.once('error', function () {});\n                  request.abort();\n                  return;\n                }\n\n                currentRequest = request;\n                request.once('error', function (error) {\n                  if (request.aborted) {\n                    return;\n                  }\n\n                  if (error instanceof timedOut.TimeoutError) {\n                    error = new TimeoutError(error, options);\n                  } else {\n                    error = new RequestError(error, options);\n                  }\n\n                  if (emitter.retry(error) === false) {\n                    emitError(error);\n                  }\n                });\n                timings = timer(request);\n                progress.upload(request, emitter, uploadBodySize);\n\n                if (options.gotTimeout) {\n                  timedOut(request, options.gotTimeout, options);\n                }\n\n                emitter.emit('request', request);\n\n                var uploadComplete = function uploadComplete() {\n                  request.emit('upload-complete');\n                };\n\n                try {\n                  if (is.nodeStream(options.body)) {\n                    options.body.once('end', uploadComplete);\n                    options.body.pipe(request);\n                    options.body = undefined;\n                  } else if (options.body) {\n                    request.end(options.body, uploadComplete);\n                  } else if (input && (options.method === 'POST' || options.method === 'PUT' || options.method === 'PATCH')) {\n                    input.once('end', uploadComplete);\n                    input.pipe(request);\n                  } else {\n                    request.end(uploadComplete);\n                  }\n                } catch (error) {\n                  emitError(new RequestError(error, options));\n                }\n              };\n\n              if (options.cache) {\n                cacheableRequest = new CacheableRequest(fn.request, options.cache);\n                cacheRequest = cacheableRequest(options, handleResponse);\n                cacheRequest.once('error', function (error) {\n                  if (error instanceof CacheableRequest.RequestError) {\n                    emitError(new RequestError(error, options));\n                  } else {\n                    emitError(new CacheError(error, options));\n                  }\n                });\n                cacheRequest.once('request', handleRequest);\n              } else {\n                // Catches errors thrown by calling fn.request(...)\n                try {\n                  handleRequest(fn.request(options, handleResponse));\n                } catch (error) {\n                  emitError(new RequestError(error, options));\n                }\n              }\n\n            case 15:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n\n    return function get(_x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  emitter.retry = function (error) {\n    var backoff;\n\n    try {\n      backoff = options.retry.retries(++retryCount, error);\n    } catch (error2) {\n      emitError(error2);\n      return;\n    }\n\n    if (backoff) {\n      var retry =\n      /*#__PURE__*/\n      function () {\n        var _ref4 = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee4(options) {\n          var _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, hook;\n\n          return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  _context4.prev = 0;\n                  _iteratorNormalCompletion3 = true;\n                  _didIteratorError3 = false;\n                  _iteratorError3 = undefined;\n                  _context4.prev = 4;\n                  _iterator3 = options.hooks.beforeRetry[Symbol.iterator]();\n\n                case 6:\n                  if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {\n                    _context4.next = 13;\n                    break;\n                  }\n\n                  hook = _step3.value;\n                  _context4.next = 10;\n                  return hook(options, error, retryCount);\n\n                case 10:\n                  _iteratorNormalCompletion3 = true;\n                  _context4.next = 6;\n                  break;\n\n                case 13:\n                  _context4.next = 19;\n                  break;\n\n                case 15:\n                  _context4.prev = 15;\n                  _context4.t0 = _context4[\"catch\"](4);\n                  _didIteratorError3 = true;\n                  _iteratorError3 = _context4.t0;\n\n                case 19:\n                  _context4.prev = 19;\n                  _context4.prev = 20;\n\n                  if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                    _iterator3.return();\n                  }\n\n                case 22:\n                  _context4.prev = 22;\n\n                  if (!_didIteratorError3) {\n                    _context4.next = 25;\n                    break;\n                  }\n\n                  throw _iteratorError3;\n\n                case 25:\n                  return _context4.finish(22);\n\n                case 26:\n                  return _context4.finish(19);\n\n                case 27:\n                  _context4.next = 29;\n                  return get(options);\n\n                case 29:\n                  _context4.next = 34;\n                  break;\n\n                case 31:\n                  _context4.prev = 31;\n                  _context4.t1 = _context4[\"catch\"](0);\n                  emitError(_context4.t1);\n\n                case 34:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4, null, [[0, 31], [4, 15, 19, 27], [20,, 22, 26]]);\n        }));\n\n        return function retry(_x4) {\n          return _ref4.apply(this, arguments);\n        };\n      }();\n\n      setTimeout(retry, backoff, _objectSpread({}, options, {\n        forceRefresh: true\n      }));\n      return true;\n    }\n\n    return false;\n  };\n\n  emitter.abort = function () {\n    if (currentRequest) {\n      currentRequest.once('error', function () {});\n      currentRequest.abort();\n    } else {\n      shouldAbort = true;\n    }\n  };\n\n  setImmediate(\n  /*#__PURE__*/\n  _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee5() {\n    var body, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, hook;\n\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.prev = 0;\n            // Convert buffer to stream to receive upload progress events (#322)\n            body = options.body;\n\n            if (!is.buffer(body)) {\n              _context5.next = 7;\n              break;\n            }\n\n            options.body = toReadableStream(body);\n            uploadBodySize = body.length;\n            _context5.next = 10;\n            break;\n\n          case 7:\n            _context5.next = 9;\n            return getBodySize(options);\n\n          case 9:\n            uploadBodySize = _context5.sent;\n\n          case 10:\n            if (is.undefined(options.headers['content-length']) && is.undefined(options.headers['transfer-encoding'])) {\n              if ((uploadBodySize > 0 || options.method === 'PUT') && !is.null(uploadBodySize)) {\n                options.headers['content-length'] = uploadBodySize;\n              }\n            }\n\n            _iteratorNormalCompletion4 = true;\n            _didIteratorError4 = false;\n            _iteratorError4 = undefined;\n            _context5.prev = 14;\n            _iterator4 = options.hooks.beforeRequest[Symbol.iterator]();\n\n          case 16:\n            if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {\n              _context5.next = 23;\n              break;\n            }\n\n            hook = _step4.value;\n            _context5.next = 20;\n            return hook(options);\n\n          case 20:\n            _iteratorNormalCompletion4 = true;\n            _context5.next = 16;\n            break;\n\n          case 23:\n            _context5.next = 29;\n            break;\n\n          case 25:\n            _context5.prev = 25;\n            _context5.t0 = _context5[\"catch\"](14);\n            _didIteratorError4 = true;\n            _iteratorError4 = _context5.t0;\n\n          case 29:\n            _context5.prev = 29;\n            _context5.prev = 30;\n\n            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n              _iterator4.return();\n            }\n\n          case 32:\n            _context5.prev = 32;\n\n            if (!_didIteratorError4) {\n              _context5.next = 35;\n              break;\n            }\n\n            throw _iteratorError4;\n\n          case 35:\n            return _context5.finish(32);\n\n          case 36:\n            return _context5.finish(29);\n\n          case 37:\n            requestUrl = options.href || new URL(options.path, urlLib.format(options)).toString();\n            _context5.next = 40;\n            return get(options);\n\n          case 40:\n            _context5.next = 45;\n            break;\n\n          case 42:\n            _context5.prev = 42;\n            _context5.t1 = _context5[\"catch\"](0);\n            emitError(_context5.t1);\n\n          case 45:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5, null, [[0, 42], [14, 25, 29, 37], [30,, 32, 36]]);\n  })));\n  return emitter;\n};","map":null,"metadata":{},"sourceType":"script"}