{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/tingyuan.lu/chatkit/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"/Users/tingyuan.lu/chatkit/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _objectSpread = require(\"/Users/tingyuan.lu/chatkit/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar _require = require('url'),\n    URL = _require.URL,\n    URLSearchParams = _require.URLSearchParams; // TODO: Use the `URL` global when targeting Node.js 10\n\n\nvar urlLib = require('url');\n\nvar is = require('@sindresorhus/is');\n\nvar urlParseLax = require('url-parse-lax');\n\nvar lowercaseKeys = require('lowercase-keys');\n\nvar urlToOptions = require('./utils/url-to-options');\n\nvar isFormData = require('./utils/is-form-data');\n\nvar merge = require('./merge');\n\nvar knownHookEvents = require('./known-hook-events');\n\nvar retryAfterStatusCodes = new Set([413, 429, 503]); // `preNormalize` handles static options (e.g. headers).\n// For example, when you create a custom instance and make a request\n// with no static changes, they won't be normalized again.\n//\n// `normalize` operates on dynamic options - they cannot be saved.\n// For example, `body` is everytime different per request.\n// When it's done normalizing the new options, it performs merge()\n// on the prenormalized options and the normalized ones.\n\nvar preNormalize = function preNormalize(options, defaults) {\n  if (is.nullOrUndefined(options.headers)) {\n    options.headers = {};\n  } else {\n    options.headers = lowercaseKeys(options.headers);\n  }\n\n  if (options.baseUrl && !options.baseUrl.toString().endsWith('/')) {\n    options.baseUrl += '/';\n  }\n\n  if (options.stream) {\n    options.json = false;\n  }\n\n  if (is.nullOrUndefined(options.hooks)) {\n    options.hooks = {};\n  } else if (!is.object(options.hooks)) {\n    throw new TypeError(\"Parameter `hooks` must be an object, not \".concat(is(options.hooks)));\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = knownHookEvents[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var event = _step.value;\n\n      if (is.nullOrUndefined(options.hooks[event])) {\n        if (defaults) {\n          options.hooks[event] = _toConsumableArray(defaults.hooks[event]);\n        } else {\n          options.hooks[event] = [];\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  if (is.number(options.timeout)) {\n    options.gotTimeout = {\n      request: options.timeout\n    };\n  } else if (is.object(options.timeout)) {\n    options.gotTimeout = options.timeout;\n  }\n\n  delete options.timeout;\n  var retry = options.retry;\n  options.retry = {\n    retries: 0,\n    methods: [],\n    statusCodes: [],\n    errorCodes: []\n  };\n\n  if (is.nonEmptyObject(defaults) && retry !== false) {\n    options.retry = _objectSpread({}, defaults.retry);\n  }\n\n  if (retry !== false) {\n    if (is.number(retry)) {\n      options.retry.retries = retry;\n    } else {\n      options.retry = _objectSpread({}, options.retry, retry);\n    }\n  }\n\n  if (options.gotTimeout) {\n    options.retry.maxRetryAfter = Math.min.apply(Math, _toConsumableArray([options.gotTimeout.request, options.gotTimeout.connection].filter(function (n) {\n      return !is.nullOrUndefined(n);\n    })));\n  }\n\n  if (is.array(options.retry.methods)) {\n    options.retry.methods = new Set(options.retry.methods.map(function (method) {\n      return method.toUpperCase();\n    }));\n  }\n\n  if (is.array(options.retry.statusCodes)) {\n    options.retry.statusCodes = new Set(options.retry.statusCodes);\n  }\n\n  if (is.array(options.retry.errorCodes)) {\n    options.retry.errorCodes = new Set(options.retry.errorCodes);\n  }\n\n  return options;\n};\n\nvar normalize = function normalize(url, options, defaults) {\n  if (is.plainObject(url)) {\n    options = _objectSpread({}, url, options);\n    url = options.url || {};\n    delete options.url;\n  }\n\n  if (defaults) {\n    options = merge({}, defaults.options, options ? preNormalize(options, defaults.options) : {});\n  } else {\n    options = merge({}, preNormalize(options));\n  }\n\n  if (!is.string(url) && !is.object(url)) {\n    throw new TypeError(\"Parameter `url` must be a string or object, not \".concat(is(url)));\n  }\n\n  if (is.string(url)) {\n    if (options.baseUrl) {\n      if (url.toString().startsWith('/')) {\n        url = url.toString().slice(1);\n      }\n\n      url = urlToOptions(new URL(url, options.baseUrl));\n    } else {\n      url = url.replace(/^unix:/, 'http://$&');\n      url = urlParseLax(url);\n    }\n  } else if (is(url) === 'URL') {\n    url = urlToOptions(url);\n  } // Override both null/undefined with default protocol\n\n\n  options = merge({\n    path: ''\n  }, url, {\n    protocol: url.protocol || 'https:'\n  }, options);\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = options.hooks.init[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var hook = _step2.value;\n      var called = hook(options);\n\n      if (is.promise(called)) {\n        throw new TypeError('The `init` hook must be a synchronous function');\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  var _options = options,\n      baseUrl = _options.baseUrl;\n  Object.defineProperty(options, 'baseUrl', {\n    set: function set() {\n      throw new Error('Failed to set baseUrl. Options are normalized already.');\n    },\n    get: function get() {\n      return baseUrl;\n    }\n  });\n  var _options2 = options,\n      query = _options2.query;\n\n  if (is.nonEmptyString(query) || is.nonEmptyObject(query) || query instanceof URLSearchParams) {\n    if (!is.string(query)) {\n      options.query = new URLSearchParams(query).toString();\n    }\n\n    options.path = \"\".concat(options.path.split('?')[0], \"?\").concat(options.query);\n    delete options.query;\n  }\n\n  if (options.hostname === 'unix') {\n    var matches = /(.+?):(.+)/.exec(options.path);\n\n    if (matches) {\n      var _matches = _slicedToArray(matches, 3),\n          socketPath = _matches[1],\n          path = _matches[2];\n\n      options = _objectSpread({}, options, {\n        socketPath: socketPath,\n        path: path,\n        host: null\n      });\n    }\n  }\n\n  var _options3 = options,\n      headers = _options3.headers;\n\n  for (var _i = 0, _Object$entries = Object.entries(headers); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n        key = _Object$entries$_i[0],\n        value = _Object$entries$_i[1];\n\n    if (is.nullOrUndefined(value)) {\n      delete headers[key];\n    }\n  }\n\n  if (options.json && is.undefined(headers.accept)) {\n    headers.accept = 'application/json';\n  }\n\n  if (options.decompress && is.undefined(headers['accept-encoding'])) {\n    headers['accept-encoding'] = 'gzip, deflate';\n  }\n\n  var _options4 = options,\n      body = _options4.body;\n\n  if (is.nullOrUndefined(body)) {\n    options.method = options.method ? options.method.toUpperCase() : 'GET';\n  } else {\n    var isObject = is.object(body) && !is.buffer(body) && !is.nodeStream(body);\n\n    if (!is.nodeStream(body) && !is.string(body) && !is.buffer(body) && !(options.form || options.json)) {\n      throw new TypeError('The `body` option must be a stream.Readable, string or Buffer');\n    }\n\n    if (options.json && !(isObject || is.array(body))) {\n      throw new TypeError('The `body` option must be an Object or Array when the `json` option is used');\n    }\n\n    if (options.form && !isObject) {\n      throw new TypeError('The `body` option must be an Object when the `form` option is used');\n    }\n\n    if (isFormData(body)) {\n      // Special case for https://github.com/form-data/form-data\n      headers['content-type'] = headers['content-type'] || \"multipart/form-data; boundary=\".concat(body.getBoundary());\n    } else if (options.form) {\n      headers['content-type'] = headers['content-type'] || 'application/x-www-form-urlencoded';\n      options.body = new URLSearchParams(body).toString();\n    } else if (options.json) {\n      headers['content-type'] = headers['content-type'] || 'application/json';\n      options.body = JSON.stringify(body);\n    }\n\n    options.method = options.method ? options.method.toUpperCase() : 'POST';\n  }\n\n  if (!is.function(options.retry.retries)) {\n    var retries = options.retry.retries;\n\n    options.retry.retries = function (iteration, error) {\n      if (iteration > retries) {\n        return 0;\n      }\n\n      if ((!error || !options.retry.errorCodes.has(error.code)) && (!options.retry.methods.has(error.method) || !options.retry.statusCodes.has(error.statusCode))) {\n        return 0;\n      }\n\n      if (Reflect.has(error, 'headers') && Reflect.has(error.headers, 'retry-after') && retryAfterStatusCodes.has(error.statusCode)) {\n        var after = Number(error.headers['retry-after']);\n\n        if (is.nan(after)) {\n          after = Date.parse(error.headers['retry-after']) - Date.now();\n        } else {\n          after *= 1000;\n        }\n\n        if (after > options.retry.maxRetryAfter) {\n          return 0;\n        }\n\n        return after;\n      }\n\n      if (error.statusCode === 413) {\n        return 0;\n      }\n\n      var noise = Math.random() * 100;\n      return Math.pow(2, iteration - 1) * 1000 + noise;\n    };\n  }\n\n  return options;\n};\n\nvar reNormalize = function reNormalize(options) {\n  return normalize(urlLib.format(options), options);\n};\n\nmodule.exports = normalize;\nmodule.exports.preNormalize = preNormalize;\nmodule.exports.reNormalize = reNormalize;","map":null,"metadata":{},"sourceType":"script"}